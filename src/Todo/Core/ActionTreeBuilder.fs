namespace Todo.Core.ActionTreeBuilder

open System
open System.Reflection
open Microsoft.FSharp.Core
open FsToolkit.ErrorHandling

open Todo.Core.ActionTree
open Todo.Core.Utilities.Attributes.ActionTree
open Todo.Core.Utilities.Exceptions
open Todo.Core.Utilities.Exceptions.ActionTree



// An intermediate representation of an action module to be able to easier verify constraints.
type internal ModuleData =
    { ActionModule: ActionModuleAttribute
      DefaultActionFunctions: MethodInfo list 
      ActionFunctions: MethodInfo list
      Attributes: PresentAttributes
       }
and PresentAttributes =
    { SingleActionAttribute: SingleActionAttribute option }



// Module containing functions that find types with specific attributes related to action tree building. Additionally
// provides functions that extract data from these attributes.
module internal AttributeFinder =
    
    // Checks if the type has the correct 'CompilationMappingAttribute' configuration that is generated by the compiler.
    // Effectively asserts that the type is a module, not a class, attribute, function, etc.
    let private hasCompilationMappingAttribute (sourceConstructFlag: SourceConstructFlags) (_type: Type) : bool =
        if _type.GetCustomAttributes(typeof<CompilationMappingAttribute>, false).Length > 0 then
           let foundAttribute = _type.GetCustomAttribute(typeof<CompilationMappingAttribute>) :?> CompilationMappingAttribute
           foundAttribute.SourceConstructFlags = sourceConstructFlag 
        else
            false
            
    let internal getActionFunctionName (methodInfo: MethodInfo) =
        (methodInfo.GetCustomAttribute(typeof<ActionFunctionAttribute>, false) :?> ActionFunctionAttribute).Name
        
    let internal getActionModuleName (_type: Type) =
        (_type.GetCustomAttribute(typeof<ActionModuleAttribute>, false) :?> ActionModuleAttribute).ModuleName
                
    /// <summary>
    /// Gets all modules with the attribute "ActionModule".
    /// </summary>
    /// <remarks>
    /// Any other source construct other than a module (UnionTypes, RecordTypes, etc.) will be ignored.
    /// </remarks>
    let getActionModuleTypes () : Type array =
        Assembly.GetExecutingAssembly().GetTypes()
        |> Array.filter (fun _type -> _type.IsClass)
        |> Array.filter (fun _type -> _type.GetCustomAttributes(typeof<ActionModuleAttribute>, false).Length > 0)
        |> Array.filter (hasCompilationMappingAttribute SourceConstructFlags.Module)
        
    /// <summary>
    /// Gets all modules with the attribute "DefaultActionModule".
    /// </summary>
    /// <remarks>
    /// Any other source construct other than a module (UnionTypes, RecordTypes, etc.) will be ignored.
    /// </remarks>
    let getDefaultActionModuleTypes () : Type array =
        Assembly.GetExecutingAssembly().GetTypes()
        |> Array.filter (fun _type -> _type.IsClass)
        |> Array.filter (fun _type -> _type.GetCustomAttributes(typeof<DefaultActionModuleAttribute>, false).Length > 0)
        |> Array.filter (hasCompilationMappingAttribute SourceConstructFlags.Module)
        
    
    /// <summary>
    /// Gets all functions inside a module that have the "ActionFunction" attribute.
    /// </summary>
    let getActionFunctions (_type: Type) =
        _type.GetMethods()
        |> Array.filter (fun methodInfo -> methodInfo.GetCustomAttributes(typeof<ActionFunctionAttribute>, false).Length > 0)
        
    /// <summary>
    /// Gets all functions inside a module that have the "DefaultActionFunction" AND "ActionFunction" attribute.
    /// </summary>
    let getDefaultActionFunctions (_type: Type) =
        _type.GetMethods()
        |> Array.filter (fun methodInfo -> methodInfo.GetCustomAttributes(typeof<DefaultActionFunctionAttribute>, false).Length > 0)
        |> Array.filter (fun methodInfo -> methodInfo.GetCustomAttributes(typeof<ActionFunctionAttribute>, false).Length > 0)
        
        
        
//  Module containing functions that validates and enforces constraints of the action tree and its constituent module data
module internal Validation =
    
    // Nested module containing functions that have functions related to validating constraints on an module data
    // record.
    module internal ModuleData =
        
        // Takes a list, filters elements that have duplicates in the list, returns a sub-list containing those duplicates.
        let private getDuplicates list =
            list
            |> List.groupBy id
            |> List.filter (fun (_, group) -> List.length group > 1)
            |> List.collect snd
            |> List.distinct
        
        //  Ensures that the action module has at the very least one action function.
        let internal ensureAtLeastOneActionFunction
            (moduleData: ModuleData)
            : Result<ModuleData, ActionTreeException> =
            match List.length moduleData.ActionFunctions with
            | 0 -> Error (NoActionFunctionException(moduleData.ActionModule.ModuleName))
            | _ -> Ok moduleData
        
        //  Ensures that the action module contains exactly 0 or 1 default action functions.
        let internal ensureCorrectNumberOfDefaultActionFunctions 
            (moduleData: ModuleData)
            : Result<ModuleData, ActionTreeException> =
            match List.length moduleData.DefaultActionFunctions with
            | 0 -> Ok moduleData
            | 1 -> Ok moduleData
            | _ -> Error (MultipleDefaultActionFunctionsException(moduleData.ActionModule.ModuleName))
            
        // Ensures that each action function in a module has distinct action function names.
        let internal ensureDistinctActionFunctionNames
            (moduleData: ModuleData)
            : Result<ModuleData, ActionTreeException> =
            let actionFunctionNames =
                moduleData.ActionFunctions
                |> List.map (fun methodInfo -> methodInfo.GetCustomAttribute(typeof<ActionFunctionAttribute>))
                |> List.map (fun actionFunctionAttribute -> (actionFunctionAttribute :?> ActionFunctionAttribute).Name)
                
            match (List.length actionFunctionNames) - (List.length (List.distinct actionFunctionNames)) with
            | 0 -> Ok moduleData    //  difference of zero means List.distinct did not remove any elements -> no dupes
            | _ -> Error (IdenticalActionFunctionNamesException(moduleData.ActionModule.ModuleName, List.head (getDuplicates actionFunctionNames)))

        //  Ensures that, if the module contains the 'SingleAction' attribute, the module follows the attribute's constraints.
        let internal validateSingleActionAttributeConstraint
            (moduleData: ModuleData)
            : Result<ModuleData, ActionTreeException> =
            if Option.isSome moduleData.Attributes.SingleActionAttribute then
                match List.length moduleData.ActionFunctions with
                | 1 -> Ok moduleData
                | _ -> Error (InvalidSingleActionAttributeException(moduleData.ActionModule.ModuleName))
            else
                Ok moduleData
                
        /// <summary>
        /// Examines the passed <c>ModuleData</c> record instance, and returns some <c>ActionTreeException</c> if there are
        /// any errors. Otherwise, returns <c>None</c>, indicating that the record is valid.
        /// </summary>
        let validateModuleData
            (moduleData: ModuleData)
            : Result<ModuleData, ActionTreeException> =
            moduleData
            |> Ok 
            |> Result.bind ensureAtLeastOneActionFunction
            |> Result.bind ensureCorrectNumberOfDefaultActionFunctions
            |> Result.bind ensureDistinctActionFunctionNames
            |> Result.bind validateSingleActionAttributeConstraint
                
    //  Validates a type that it matches the constraints of the default action module, that being it contains one and only
    //  one action function. 
    let private validateDefaultActionModule
        (actionTree: ActionTree)
        (actionModuleType: Type)
        : Result<ActionTree, ActionTreeException> =
            
        let defaultActionFunctions =
            actionModuleType.GetMethods()
            |> Array.filter (fun methodInfo -> methodInfo.GetCustomAttributes(typeof<DefaultActionFunctionAttribute>, false).Length > 0)
            |> Array.filter (fun methodInfo -> methodInfo.GetCustomAttributes(typeof<ActionFunctionAttribute>, false).Length > 0)

        match Array.length defaultActionFunctions with
        | 1 -> Ok actionTree 
        | _ -> Error (InvalidDefaultActionModuleException())
        
    /// <summary>
    /// Validates that an action tree has a valid default action module.
    /// </summary>
    let validateDefaultModuleConfiguration
        (actionTree: ActionTree)
        : Result<ActionTree, ActionTreeException> =
        let defaultActionModuleTypes = AttributeFinder.getDefaultActionModuleTypes ()
        match Array.length defaultActionModuleTypes with
        | 0 -> Ok actionTree
        | 1 -> validateDefaultActionModule actionTree defaultActionModuleTypes[0]
        | _ -> Error (InvalidDefaultActionModuleException())
            
    // TODO: Implement
    /// <summary>
    /// Validates no action module has the same name.
    /// </summary>
    let validateUniqueActionModuleNames
        (actionTree: ActionTree)
        : Result<ActionTree, ActionTreeException> =
        Ok actionTree 
            
            
        
/// <summary>
/// This module contains functions that build the action tree.
/// </summary>
module TreeBuilding =
   
    open Validation.ModuleData 
    
    //  Given a module data record type, returns a list of action function names paired with its corresponding methodinfo
    let private getFunctionsFromModuleData
        (moduleData: ModuleData)
        : (string * MethodInfo) list =
        let names =
            moduleData.ActionFunctions
            |> List.map (fun methodInfo -> methodInfo.GetCustomAttribute(typeof<ActionFunctionAttribute>) :?> ActionFunctionAttribute)
            |> List.map (fun attribute -> attribute.Name)
            
        List.zip names moduleData.ActionFunctions
    
    // Attempts to parse the passed types into a module data record type. Does NOT return exceptions, only 'None'.
    let internal parseIntoModuleData
        (_type: Type)
        : ModuleData option =
        if _type.GetCustomAttributes(typeof<ActionModuleAttribute>, false).Length > 0 then
            let actionModule = _type.GetCustomAttribute(typeof<ActionModuleAttribute>) :?> ActionModuleAttribute
            let defaultActionFunctions = Array.toList (AttributeFinder.getDefaultActionFunctions _type)
            let actionFunctions = Array.toList (AttributeFinder.getActionFunctions _type)
            
            let singleActionAttribute =
                match _type.GetCustomAttribute(typeof<SingleActionAttribute>) with
                | null -> None
                | value -> Some (value :?> SingleActionAttribute)
                
            let presentAttributes = { SingleActionAttribute = singleActionAttribute }
            
            Some { ActionModule = actionModule
                   ActionFunctions = actionFunctions
                   DefaultActionFunctions = defaultActionFunctions
                   Attributes = presentAttributes }
        else
            None
            
    //  Gets a list of module data. Does so by searching for types with specific attributes.
    let internal getModuleDatalist
        ()
        : ModuleData list =
        AttributeFinder.getActionModuleTypes ()
        |> Array.map parseIntoModuleData
        |> Array.filter Option.isSome
        |> Array.map Option.get
        |> Array.toList
        
    //  Validates each module data in the list. If an exception is returned from any of the module data, propagate the exception.
    let internal validateModuleDataList
        (moduleDataList: ModuleData list)
        : Result<ModuleData list, ActionTreeException> =
        let validationStatuses = List.map validateModuleData moduleDataList
        
        let invalidModuleDataList = validationStatuses
                                    |> List.filter (fun result -> match result with | Ok _ -> false | Error _ -> true)
                                    |> List.map (fun result -> match result with | Ok _ -> failwith "error" | Error err -> err)
        
        match List.length invalidModuleDataList with
        | 0 -> Ok moduleDataList
        | _ -> Error (List.head invalidModuleDataList)
        
    //  Parses hte list of module data records into the initial action tree.
    let internal parseIntoActionTree 
        (moduleDataList: ModuleData list)
        : Result<ActionTree, ActionTreeException> =
        let leaves = moduleDataList
                     |> List.map getFunctionsFromModuleData
                     |> List.map (List.map ActionTree.Action) 
            
        let nodes = moduleDataList
                    |> List.map (fun moduleData -> (moduleData.ActionModule.ModuleName, Option<MethodInfo>.None))
            
        let paired = List.zip nodes leaves
        
        
        let branches = paired
                       |> List.map (fun pair ->
                                    let nodeInfo, leaves = pair
                                    let name, methodInfo = nodeInfo
                                    ActionTree.InternalNode (name, methodInfo, leaves))
            
        Ok (ActionTree.InternalNode ("root", None, branches))
         
        
    /// <summary>
    /// Builds the action tree.
    /// </summary>
    let buildActionTree
        ()
        : Result<ActionTree, ActionTreeException> =
        getModuleDatalist ()
        |> validateModuleDataList
        |> Result.bind validateModuleDataList
        |> Result.bind parseIntoActionTree
        |> Result.bind Validation.validateUniqueActionModuleNames 
        |> Result.bind Validation.validateDefaultModuleConfiguration 
        
            
    /// <summary>
    /// Prints a formatted representation of an action tree.
    /// </summary>
    let printActionTree
        (actionTree: ActionTree)
        : unit =
    
        // recursive helper function
        let rec print actionTree depth : unit =
            let tabs = String.replicate depth "\t"
            
            match actionTree with
            | InternalNode(str, _, actionTrees) ->
                let functionInformation = $"(FUNC: \"%s{str}\")"
                printfn $"%s{tabs}{str} {functionInformation}"
                
                for branch in actionTrees do
                    print branch (depth + 1)
                    
            | Action(str, _) ->
                let functionInformation = $"(FUNC: \"%s{str}\")"
                printfn $"%s{tabs}{str} {functionInformation}"
            
        print actionTree 0